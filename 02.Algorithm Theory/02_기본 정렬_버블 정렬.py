"""
>> 정렬 (sorting) 이란?
정렬 (sorting): 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 것
    - 정렬은 프로그램 작성시 빈번하게 필요로 함
    - 다양한 알고리즘이 고안되었으며, 알고리즘 학습의 필수
    - 다양한 정렬 알고리즘 이해를 통해, 동일한 문제에 대해 다양한 알고리즘이 고안될 수 있음을 이해하고,
      각 알고리즘간 성능 비교를 통해, 알고리즘 성능 분석에 대해서도 이해할 수 있음

>> 버블 정렬 (bubble sort) 란?
= 두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘

>> 버블 정렬의 시간 복잡도
    - 반복문이 두 개 O(n^2)
    - 최악의 경우, n * (n - 1) / 2
    - 완전 정렬이 되어 있는 상태라면 최선은 O(n)
"""
"""
연습 1. 데이터가 두 개일 때 버블 정렬 알고리즘 방식으로 정렬해보세요
"""
data_1 = [2, 1]
if data_1[0] > data_1[1]:
    data_1[0], data_1[1] = data_1[1], data_1[0]
print(data_1)

"""
연습 2. 데이터가 네 개일 때 버블 정렬 알고리즘 방식으로 정렬해보세요

예: data_list = [1, 9, 3, 2]
    1차 로직 적용
        1 와 9 비교, 자리바꿈없음 [1, 9, 3, 2]
        9 와 3 비교, 자리바꿈 [1, 3, 9, 2]
        9 와 2 비교, 자리바꿈 [1, 3, 2, 9]
    2차 로직 적용
        1 와 3 비교, 자리바꿈없음 [1, 3, 2, 9]
        3 과 2 비교, 자리바꿈 [1, 2, 3, 9]
        3 와 9 비교, 자리바꿈없음 [1, 2, 3, 9]
    3차 로직 적용
        1 과 2 비교, 자리바꿈없음 [1, 2, 3, 9]
        2 과 3 비교, 자리바꿈없음 [1, 2, 3, 9]
        3 과 9 비교, 자리바꿈없음 [1, 2, 3, 9]

> 그럼 이를 일반화 해보자
    - n개의 리스트에서 최대 n-1번의 로직 수행(맨 마지막 원소는 어차피 비교할 필요가 없다)
    - 로직을 1회 적용할 때마다 가장 큰 숫자가 뒤에서부터 1개씩 정렬된다.
    - 로직이 경우에 따라 중간에 끝날수도 있다. 
      만약, 로직을 적용할 때, 한번도 위치교환이 일어난 적이 없으면 이미 정렬이 완료된 것이다.
"""
import random
random.seed(428)


def bubble_sort(data):
    for i in range(len(data)):
        swap = False    # 교환 여부 판단
        for index in range(len(data) -1 ):   # 맨 마지막 원소는 반복할 필요 없으므로
            if data[index] > data[index+1]:  # 원소와 그 다음 원소 비교해서
                # 앞에 것이 더 크다면 위치 교환
                data[index], data[index+1] = data[index+1], data[index]
                swap = True                 # 교환이 발생했으므로 True
        if swap == False:                   # 교환이 발생하지 않았다면 정렬이 완료된 것이므로
            break

    return data


if __name__ == '__main__':
    data = random.sample(range(100), 50)
    print(data)
    print(bubble_sort(data))